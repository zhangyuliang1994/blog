1:HL["/_next/static/css/9e4bf6d932073eda.css",{"as":"style"}]
2:HL["/_next/static/css/9fdfe6c99f25ae04.css",{"as":"style"}]
0:["WxSaiTKAe0ZRSDhyMun6C",[[["",{"children":["docs",{"children":[["slug","02-ai-tools/2.3-figma-ui-design","oc"],{"children":["__PAGE__?{\"slug\":[\"02-ai-tools\",\"2.3-figma-ui-design\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/9e4bf6d932073eda.css","precedence":"next"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/9fdfe6c99f25ae04.css","precedence":"next"}]],"$L4"]]]]
5:I{"id":8464,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","185:static/chunks/app/layout-3be1eb8b2a6e8932.js"],"name":"ThemeProviders","async":false}
6:I{"id":8440,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","185:static/chunks/app/layout-3be1eb8b2a6e8932.js"],"name":"KBarSearchProvider","async":false}
7:I{"id":6481,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","185:static/chunks/app/layout-3be1eb8b2a6e8932.js"],"name":"","async":false}
8:I{"id":1229,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","185:static/chunks/app/layout-3be1eb8b2a6e8932.js"],"name":"","async":false}
9:I{"id":7767,"chunks":["272:static/chunks/webpack-2cb9ac6e9ccb1c1f.js","216:static/chunks/vendors-8842281dd4cb299e.js"],"name":"default","async":false}
a:I{"id":7920,"chunks":["272:static/chunks/webpack-2cb9ac6e9ccb1c1f.js","216:static/chunks/vendors-8842281dd4cb299e.js"],"name":"default","async":false}
b:I{"id":6685,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","185:static/chunks/app/layout-3be1eb8b2a6e8932.js"],"name":"","async":false}
c:I{"id":1928,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","189:static/chunks/app/docs/[[...slug]]/page-99627d753be593de.js"],"name":"","async":false}
10:I{"id":1329,"chunks":["216:static/chunks/vendors-8842281dd4cb299e.js","185:static/chunks/app/layout-3be1eb8b2a6e8932.js"],"name":"","async":false}
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"晓风的博客"}],["$","meta","2",{"name":"description","content":"技术探索与分享"}],["$","link","3",{"rel":"manifest","href":"/static/favicons/site.webmanifest"}],["$","meta","4",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","5",{"name":"robots","content":"index, follow"}],["$","meta","6",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","7",{"rel":"canonical","href":"https://xiaofeng.show/docs/02-ai-tools/2.3-figma-ui-design"}],["$","link","8",{"rel":"alternate","type":"application/rss+xml","href":"https://xiaofeng.show/feed.xml"}],["$","meta","9",{"property":"og:title","content":"晓风的博客"}],["$","meta","10",{"property":"og:description","content":"技术探索与分享"}],["$","meta","11",{"property":"og:url","content":"https://xiaofeng.show/docs/02-ai-tools/2.3-figma-ui-design"}],["$","meta","12",{"property":"og:site_name","content":"晓风的博客"}],["$","meta","13",{"property":"og:locale","content":"en_US"}],["$","meta","14",{"property":"og:image","content":"https://xiaofeng.show/static/images/twitter-card.png"}],["$","meta","15",{"property":"og:type","content":"website"}],["$","meta","16",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","17",{"name":"twitter:title","content":"晓风的博客"}],["$","meta","18",{"name":"twitter:description","content":"技术探索与分享"}],["$","meta","19",{"name":"twitter:image","content":"https://xiaofeng.show/static/images/twitter-card.png"}],["$","link","20",{"rel":"icon","href":"/static/favicons/favicon-16x16.png","sizes":"16x16","type":"image/png"}],["$","link","21",{"rel":"icon","href":"/static/favicons/favicon-32x32.png","sizes":"32x32","type":"image/png"}],["$","link","22",{"rel":"apple-touch-icon","href":"/static/favicons/apple-touch-icon.png","sizes":"76x76","type":"image/png"}],["$","link","23",{"rel":"mask-icon","href":"/static/favicons/safari-pinned-tab.svg"}]]
d:T58b6,
# 2.3 🎨 Figma: UI设计

## Figma 入门手册

官方网站：https://www.figma.com/

**Figma 是一个专业的 UI/UX 设计工具**，作为一个基于浏览器的设计工具，它让设计变得更加高效和协作。

既然是新手学习 Figma 教程，那么优先学会基础才是关键。

<video controls width="100%" style={{maxWidth: '800px'}}>
  <source src="https://minio.xiaofeng.show/ai-code/2.3.mp4" type="video/mp4" />
  您的浏览器不支持视频标签。
</video>

## Figma的使用场景

要做一个自己的产品，在哪里会用到 Figma 呢？我们并不需要会用Figma的所有功能，我这里总结了几个场景，大家可以参考一下，视频中也会做几个案例，会用这些就够了。

### 1. Logo设计

- Favicon导出(favicon generator)
- 网站中的logo素材

### 2. 网站开发会用到的图片素材

- OG Image 设计
- 产品的市场截图设计
- 网站中的图片素材输出
- 使用 Mockup 输出图片
- 抠图(background remover)
- 改变尺寸导出(导出用户头像，产品截图等)
- WebP Exporter

## 官方教程

也许市面上有很多人推荐的 Figma 教程五花八门，但大道至简，很多人都会忽略一个学习资源 —— 官方的学习文档与教程。对于新手学习 Figma，其实官方的教程就足够了。

你可以访问 [Figma Resource Library](https://www.figma.com/resource-library/) 获取官方的学习资源，这里提供了全面的学习材料，从基础到进阶的内容应有尽有。

点击路径如下：官网下拉到底，在「资源」-「设计学习」中就能够看到课程。

![](https://s.web.cafe/image/e3275d5a1f3f47a3b4e4a11756b3831f.png)

![](https://s.web.cafe/image/7d5e4c2b1c404e7285c8d68eb726fb75.png)

## 小白的Figma入门手册(南山可-站酷ZCOOL)

URL Source: https://www.zcool.com.cn/article/ZMTE5MzAwNA==.html?

![](https://s.web.cafe/image/bbaa39961e764e2587c1c044350837cc.jpg)

## 一、figma基础介绍

### Figma界面介绍

![](https://s.web.cafe/image/e861cf275029485093f2ce41087fe43c.png)

Figma基础界面与常规设计软件没有太多差异，有Sketch使用经验的用户几乎可以无缝衔接到Figma上。

### 顶部导航栏

顶部为导航栏，已打开的所有文档都会在这里展示，左侧Figma icon为Home键，点击回到团队主页，右侧导航Tab可以通过快捷键Command+123切换，这里的快捷键和Sketch查看全部视图的快捷键相冲突。而在Figma中，查看全部视图的快捷键是Shift+1，查看目标视图到全图大小的快捷键为Shift+2。

![](https://s.web.cafe/image/d6a9274818d646b9bcd0a98bfe7d95bb.png)

### 工具栏

基础工具栏与Sketch几乎无任何区别，从左至右分别为，移动、画板、矩形工具、钢笔工具、文字工具、视图工具、评论。而右侧功能则倾向于导出协作类操作，如Share类似蓝湖上传标注的功能，播放键则是用于运行交互原型的入口。 

![](https://s.web.cafe/image/257a82193d8846e7803fac66d5e5500b.png)

### 图层组件

左侧为常见的图层导航栏，可通过顶部在图层和组件两个模块间切换，上图中展示了图层树中不同元素的缩略图样式，其中组件和实例比较特殊，简单理解，实例是组件的复制体，需要注意的是，组件不可逆，而实例是可以逆向为Grop的，也就是取消组件化。

![](https://s.web.cafe/image/1402341031ce47b9b3cf69a11dcb274b.png)

### 属性检查器

![](https://s.web.cafe/image/b0fa495194334019a4a0409d1735d191.png)

### 帮助功能

![](https://s.web.cafe/image/fc3d2741df9040cdbb892a3c19ae1e85.png)

### Figma基础功能

### 画板 Frames

建立画板有两种常用方式。常规方式是通过快捷键F或点击工具栏画板工具来手动建立。另外一种比较自由的方式是基于选中元素创建画板。在圈中一组元素后，右键选项面板中有Frame Selection的选项和Grop Selection的选项，两者分别是建立画板和建立组，从这里也可以看出来，Figma中组Grop和画板Frame是相关性较大，较相似的概念，且在实际场景中，画板和组可以进行切换。

![](https://s.web.cafe/image/5fa8311d1c0d483dbebcce7bb4fe9b38.png)

Frame包含Grop，Grop单纯的代表对一些元素的打包与整合，与常规设计软件中的组的概念无异，但Frame则更强调导出与自动布局、组件化等方面。例如你要将一个消息气泡组件化后，会发现其属性自动由Grop转化为Frame。

![](https://s.web.cafe/image/f6ef3ba099994f63b5c9deeb20623be6.png)

### 文字工具和字体

文字工具可以通过快捷键T快速唤醒，交互与PS近似，单击键入常规文字框，框选键入固定范围文字框。Figma的字体工具与Sketch差异点在于其共享样式，文字系统是一套设计系统的核心组成元素之一，而在Figma中，文字的样式被拆解为字体样式（涉及到文字字号、字族、字重）和颜色填充样式（颜色填充样式适用于所有元素）。

另外要提醒的一点是，Figma字距等属性默认使用百分比来界定，但它也支持常规的px形式，只需要在调整框键入你需要的值，如150%，或28px，系统会自动匹配到该类计算方式。

![](https://s.web.cafe/image/e54a4fa350d249618fcc17132312650a.png)

### 投影与模糊

属性检查器中的effect模块包含投影和模糊两部分。与Sketch完全一致，投影依靠XY和范围、透明度等属性来控制，背景模糊通过调整覆盖层Fill透明度控制，嗯，与sketch完全一致。 在由sketch迁移至figma过程会出现投影还原问题，实际上是某个开关设置的问题，只需要取消勾选Clip content.

![](https://s.web.cafe/image/fae57af8bf764fe2ac802ff5d642f5f6.png)

### 布局栅格

Figma的栅格可以很方便的在画板的属性检查器开启，寻找到Layout Grid并开启它，其中包含常用的栅格与网格两种规范方式。

![](https://s.web.cafe/image/c8ffaafad4c845a59ac080c12afeb66c.png)

### 遮罩蒙版

遮罩工具有两个入口，一是选中要运算的图形后，在顶部工具栏的中间区域点击遮罩工具，一是右键菜单中点击 Use as mask选项。

![](https://s.web.cafe/image/f29880e91b3b4704b7a5058cc90369c5.png)

### 颜色取色器

![](https://s.web.cafe/image/7275a75aca314620bf70b9ebb8a5ad8d.png)

### 布尔运算

![](https://s.web.cafe/image/60a3742ddbd4451782cb502ce9c1d84e.png)

### Figma常用快捷键

这里只统计一些特殊的、容易与sketch起冲突需要刻意记忆的、特别常用的快捷键。

![](https://s.web.cafe/image/a0e09fcc3c0c4a76bd1f7d27e07d161e.png)

### Shift+1 Shift+2

常用的放大视图工具，适用于快速查看文件全览，及快速放大某个元素的场景。

### Z+鼠标左键

按住Z快捷键，鼠标会转变为放大镜，此时单击放大视图，同时按住Option会缩小时图。拖拽一片区域则会放大该区域。

### Option+鼠标左键

Figma的右侧属性检查器无法快捷hover在属性值上拖动（需要谨慎的将鼠标移动到属性icon

上），此时可以按住Option再把鼠标Hover到属性框，此时便可以直接拖动调整数值。

### Cmd+G/Cmd+Option+G

从内容打组/从内容新建画板,Figma中组和画板有很多重合的地方，与Sketch差异较大，组还是那个组，但画板可以嵌套画板， 后面会具体解释。

![](https://s.web.cafe/image/17df46118dc44b288da0a5de34b7755a.png)

### Cmd+鼠标左键

该操作可忽略画板内元素直接调整画板尺寸，适用于画板内元素未做自动布局处理，同时需要调整画板尺寸的场景，直接调整画板尺寸会使图形变形。

### Option+L

该操作可以快速收起图层，在设计过程中使用频率较高，便于高效整理图层。点击空白区执行该命令会收起所有图层，点击某个组或某个画板会收起该组或画板。注意，点击单个图层或元素无效果。

### Shift+H & Shift + V

左右翻转&上下翻转,快捷执行翻转操作，此功能使用场景较多，常规操作需要右键唤醒功能面板然后寻找到目标再执行命令，学会快捷键后可以大大提升翻转操作的效率。

### Shift+R

显示隐藏标尺，使用Sketch的用户需要克服该快捷键的使用习惯，sketch中该操作为Cmd+R。

### Control+G

显示隐藏网格，实际上不仅仅是网格工具，该快捷键唤醒的是栅格工具集合，需要在右侧属性检查器进行调整，可从网格工具转化为栅格工具，默认是网格工具。

![](https://s.web.cafe/image/f7759bac93f1435092ea7a28f9a378cc.png)

**如何复制形状属性**

与Sketch相比，Figma为了保证组件化和共享样式的细分程度，将图形的属性样式进行了更细致的拆分，如图形颜色、描边属性，字体字族、字体颜色等属性是分开处理的。因此无法像sketch或PS那样一键复制所有属性，而是需要单独选择某个属性，然后复制。

因此在遇到样式相关的问题时，可以考虑使用共享样式来实现，这也是figma官方期望设计师养成的习惯。

### Cmd+E

扩展图形，在Figma中，图形布尔运算后会保留所有原始图形，在选择图形时经常会选择到布尔前的图形，影响工作效率，在确认图形不会进行二次编辑时，可以考虑直接Command + E将图形扩展为新图形。

如果记不住快捷键，可以右键在选项面板中选择"Flatten"进行扩展图形。

### Cmd+Shift+O

扩展描边,在使用描边绘制Icon时，需要通过扩展描边来转为可编辑图形。

如果记不住快捷键，可以右键在选项面板中选择"Outline Stroke"进行扩展。

最后，需要查看所有快捷键只需要在右下角唤醒帮助功能，面板中第二个选项Keyboard Shortcuts就是快捷键演示。

## 二、Figma进阶功能

### 组件（components）

组件和实例：组件是母体，实例是复制体，组件可以删除和修改，不可逆向为组，实例不可直接编辑，但可以逆向为组，然后修改。没有一个固定位置用来存放组件，你最初组件化的那个组，就是唯一的组件母体，且组件不会被收起在一个组件页中，而是存在原本的位置。

组件和实例是分开的，简单理解就是，你最初设计的一个元素，通过Component功能打包为组件A，这个组件就是原始组件A，此时在左侧assert模块下就会存在一个固定组件(类似组件库模块)，当你从Assert模块中拖动出来一个新的组件A，或者从原始组件A复制一个新的组件A，这个新的组件A就是实例，实例可以被还原为组。

![](https://s.web.cafe/image/83e5212a1e3f464ba1d47c98039bffe0.png)

### 如何找到最初的组件？

首先需要说明，Figma的组件管理方式很灵活，但相较于Sketch的确不够规范，这里仍建议设计师新建一个layers,以组件来命名，将原始组件都放置在这个页面，易于管理。

![](https://s.web.cafe/image/da59b32ac71e433abc9535f71b99d9f8.png)

该Layer主要目的在于管理原始组件，例如当需要大批量修改组件时，切换到组件Layer快速修改，修改后快速映射到所有设计稿。

当需要调用组件时，则推荐使用官方提供的Assert模块，通过拖拽调用组件实例。

在实际工作场景中，我们需要从实例跳转到原始组件，以进行大批量效果修改时，可通过属性检查器中的组件icon快捷跳转至原始组件。

![](https://s.web.cafe/image/6bbc54abab7b4a17a14ab3ad989254d0.png)

### 实例操作

在实际工作中，我们会遇到使用一个类似组件来建立新组件的场景，此时需要将组件逆向为组，然后进行编辑，在Figma中仅实例可以进行逆向，方法是右键，或者在属性检查器区域执行Detach instance命令。

![](https://s.web.cafe/image/1f330d1536154c38b96fececb4cf15bf.png)

当直接在当前正在操作的实例上进行少量变更后，可以通过覆盖功能将当前的属性同步给组件和所有实例。

方法是在右侧属性检查器执行Push Overrides to Main Components。

### 组件库的使用

**如何上传和维护组件库？**

Figma的组件库系统极其友好，易于维护。设计师只需要将已经设计完成的组件系统和样式系统放置在一个文件中，然后就可以基于当前的文件已有的样式和组件直接建立共享组件库，只需要在Assert的Library入口进入组件窗口，通过组件库窗口中的上传（Publish）功能,完成上传，团队成员就能获得该组件库内容。

后续维护组件库的工作只需要在该文件上进行修改和完善，随后回到library窗口进行更新。当你更新组件库后，其他使用了该组件库内容的设计师会同步收到更新消息，且可以快速同步到最新版本，以保证设计一致性。

**如何使用团队成员已上传的组件库?**

在Library窗口，团队已公开的组件库会以List的形式展示，设计师只需要点击你的目标组件库左侧的switch，即可唤醒该组件库，回到你的文件画板中，此时即可调用该组件库的内容，如组件、颜色样式、字体系统等。

想要快速查看组件库内的内容可以使用Option+2，快速调起Assert资源窗口，在左侧图层列表查看。

![](https://s.web.cafe/image/8037c264a819449f8d314d5d9421c236.png)

### 响应式约束（constraints）

通过约束功能的官方定义我们更容易理解这个功能。首先要说明其限制条件，约束功能只有在Frame中才可以发挥作用，也只有Frame中的元素，才会展示Constraints工具。因此，官方定义其为："允许你将设计元素固定在父框架的不同位置"，所以，请谨记约束功能以建立Frame为前提，而其主流使用场景就是构建流畅的布局以适应不同设备尺寸，即当设计师将Frame尺寸进行变更时，Frame内的元素会自动按照预先设定的规则固定位置。

但在真实场景下，响应式约束的功能并不局限于此，它更是可复用、可快速编辑组件的必要组成条件。Figma的Frame不同于Sketch的画板工具，可以互相嵌套且不会影响到复杂度产生墒增的问题，因此可以通过Constraints配合Frame组合成规范布局的组件系统，再加上我们后面要讲的Auto layout功能，可以构建出高自由度，可任意调用，且能够根据真实填充数据自动布局的超级组件，这样构建的组件一方面还原了真实场景下的设计效果，一方面大大减少了设计师重复性工作。

下面是响应式约束的不同条件及对应的效果。

![](https://s.web.cafe/image/786b931f43bf4a6d93facdc3238e7110.png)

![](https://s.web.cafe/image/087552520a4447d5a87cd5ec34c9bb5c.png)

响应式约束的常规案例。

![](https://s.web.cafe/image/c700f33931444ad2a5ea7d0060558f94.png)

### 自动化布局（Auto layout）

自动化布局工具是制作复杂组件的核心技巧，与响应式约束搭配可以设计出高度自由可编辑的组件乃至半成品页面。

一般来说，我们谈到组件系统主要聚焦的是其规范一致性，设计资源管理等方面，**但实际上，组件库在提升设计师效率，减少重复性工作方面能够发挥更强大的作用**。常规组件调用后需要花费一定精力修改，但通过自动化布局工具设定好规则后，设计师能沉淀一整套可直接使用、根据内容填充物自动布局变化的超级组件，甚至是成熟的典型页面，可极大提升设计效率，减少在移动、复制、填充内容等基础操作上的时间浪费。

下面我实现了一个最简单的案例，再该search组件中需要填充真实数据以模拟真实场景下的样式，设计师只需要输入新的填充内容，组件内其他元素会自动匹配到对应的正确位置。

![](https://s.web.cafe/image/50fbc78c398c46f2a4d98735e4de913e.png)

自动布局按照常规布局规则划分为三个属性，分别是左右空隙、上下空隙、元素间空隙。

当选中多个元素，执行Shift+A（建议熟悉快捷键提升效率）后，会为这些元素建立自动布局，规则可以在右侧属性检查区设定。

例如我需要建立一组横排的card，此时可以先设计好三个card，然后选中它们，执行Shift+A即可创建一组横排的自动布局（横排竖排根据你真实场景下元素的排列情况，也可以在右侧更改横排为竖排）。另外一种小技巧是，直接给一个card执行Shift+A命令，然后选中组内的card执行复制命名cmd+D，后复制出的每一个card也会按照预定规则排列。

![](https://s.web.cafe/image/2879f9feaf984ce6825993745d08b938.png)

如下图案例所示，元素与元素组合构成自动布局的组件，自动布局的组件组合则能构成更复杂的大兴组件乃至典型模块、典型页面。建议设计师快速掌握该技巧的方法是将其套入实际需求中，从提升设计效率，减少重复工作的出发点开始设计自己的典型组件模块。

![](https://s.web.cafe/image/2d3b92c2010248e9b56ae03193edb452.png)

![](https://s.web.cafe/image/7a636154645843929e85430a2a8ec2de.png)

### 共享样式 （style）

关于共享样式，从sketch转型到Figma的同学应该再熟悉不过了，共享样式是组件库的核心构成之一，主要包括颜色、字体及各种样式效果。这里着重说明一下Figma共享样式与Sketch共享样式的差异。Figma中对样式进行了更为细致的划分，共包括颜色、字体、效果三类。

以颜色为例，Figma中颜色样式可自由运用到图形、描边、字体等各细分元素上面，无任何限制，可与各元素自由搭配。以字体为例，字体样式仅包括字体字号、字重、行高等字体本身的属性，不包括颜色，换言之，Font样式的颜色可以自由使用Color样式。

概括来讲，Sketch更注重常规理解下，组件系统的实际应用时的场景，如字体样式是由字体字族、字号、字重、行高、颜色所有属性一同构成的，而Figma强调更高的自由和编辑性，孰优孰劣无法一言蔽之，从严谨性和组件自我封闭完整性来讲，sketch的要更好一些，但从组件自由度，组件嵌套组合的效率上来讲Figma要更好一些，所以关键在于设计师能否合理运用，快速掌握技巧并提高效率。

![](https://s.web.cafe/image/7a262df5872b4a62baffaaf87b5498a9.png)

### 交互原型

Figma的交互功能，在设计软件中我愿称之为最强，极简的操作逻辑以及优秀的实现效果使其在中小复杂度的交互场景下不逊色于专业UI动效设计软件。在FIgma的交互模式下能看到Principle的影子，其背后的设计逻辑高度相似，符合UI设计领域快速输出产品交互物的场景。

如下图所示，界面间的交互逻辑通过选择起始画板或其中的元素然后简单的连线即可完成。当然，如果设计师不满足于此可以在右侧属性检查器制作更精致的过度效果。Figma拥有者完善的交互手势可供设计师选择，如点击、hover、拖拽等。

![](https://s.web.cafe/image/0bac6d0aa0ce4048bfa7133a199dfcca.png)

然后是过渡效果，在这里我只推荐一种交互方式，那就是Smart Animate，一句话概括，Smart Animate复刻了Principle元素演变的逻辑，所以如果你是Principle的忠实拥趸，那在FIgma交互模式下你可以无缝代入到Principle的使用经验中。

![](https://s.web.cafe/image/9ce0ffb2a2b84202a6071f1f641e7c0b.png)

除此之外，需要特殊说明的一个交互功能是弹窗交互Open Overly。使用该交互会调起一个覆盖层，适合弹窗类场景。方法如下图所示。Figma交互模块有很多功能，感兴趣的可以自行探索，而对于大部分设计师来讲，掌握最基础的Figma交互原型功能就已经能够让你的演示事半功倍了。

![](https://s.web.cafe/image/84666e4083294a85aeaaf81802a2f087.png)

### 输出

直接分享链接给对应的利益相关者即可。PM可以在视觉稿上直接评论，快捷沟通解决问题。开发可以切换到开发者模式查看切图标注。

![](https://s.web.cafe/image/cf1337733d1745f69da99291f289de76.png)

### 插件

Figma与Sketch一样有众多插件可以帮助设计师提升设计效率，甚至某些基础功能如等比缩放也需要插件帮助实现。

插件可以通过系统菜单中的Plugin来安装和调用。具体位置为Plugin-manage plugin。想要搜索新的插件只需要点开一个已安装插件，在插件详情页的顶部使用搜索工具来寻找目标插件。

下面列出了几个我最常用的插件。

**Arrow Auto**

Arrow Auto是一个原型连线工具，能够快速在选中的元素、画板间连线，且可以自由选择线段两端的样式。由于Figma官方的交互连接线需要在Protype模式下才可以查看，存在无法覆盖的场景。

因此当设计师需要快速展示交互逻辑时，Arrow Auto是一个不错的选择，。除此之外，需要输出中低保真度原型的交互设计师和PM也可以使用它来快速构建MVP原型。

![](https://s.web.cafe/image/9dbf36bac8964b3a8afcdcdfc82f2385.png)

**Time machine**

TIme machine是一款时间机器类插件，可以帮助设计师快速储存历史版本设计稿，并通过时间线命名。虽然Figma自带30天可追述历史版本的功能，但保存一份备份版文件还是有其必要性的。

设计师只需要选择对应的画板，执行plugin-TIme machine，就会自动生成一个以时间命名的Layer，用来存放历史备份。

![](https://s.web.cafe/image/341631ed3c9f4776b6157ba92f2d275b.png)

**Clean Document**

Clean Document是一款图层清理插件，可以帮助设计师快速清理隐藏的图层，解除单个图层的分组，批量规范图层命名等。设计师可以在插件页面中选择自己需要执行的清理工作，然后执行清理操作，期间需要花费一定时间，为了避免卡顿可以少量选中画板分批清理。

![](https://s.web.cafe/image/be091eab2fe84765af23383857cbf3b7.png)

**Scale**

Scale是一款等比缩放插件。由于Figma自带的等比缩放功能无法精确按照数值进行操作，因此当设计师需要对设计元素进行等比缩放时，需要适用该插件。

![](https://s.web.cafe/image/3d410ca0b6304e228c1b5c60d872f6ea.png) e:T8ca6,const _jsx = _jsx_runtime.jsx;
const _jsxs = _jsx_runtime.jsxs;
const _Fragment = _jsx_runtime.Fragment;
function _createMdxContent(props) {
  const _components = Object.assign({
    h1: "h1",
    h2: "h2",
    p: "p",
    strong: "strong",
    h3: "h3",
    ul: "ul",
    li: "li",
    a: "a",
    img: "img"
  }, props.components);
  return _jsxs(_Fragment, {
    children: [_jsx(_components.h1, {
      children: "2.3 🎨 Figma: UI设计"
    }), "\n", _jsx(_components.h2, {
      children: "Figma 入门手册"
    }), "\n", _jsx(_components.p, {
      children: "官方网站：https://www.figma.com/"
    }), "\n", _jsxs(_components.p, {
      children: [_jsx(_components.strong, {
        children: "Figma 是一个专业的 UI/UX 设计工具"
      }), "，作为一个基于浏览器的设计工具，它让设计变得更加高效和协作。"]
    }), "\n", _jsx(_components.p, {
      children: "既然是新手学习 Figma 教程，那么优先学会基础才是关键。"
    }), "\n", _jsxs("video", {
      controls: true,
      width: "100%",
      style: {
        maxWidth: '800px'
      },
      children: [_jsx("source", {
        src: "https://minio.xiaofeng.show/ai-code/2.3.mp4",
        type: "video/mp4"
      }), _jsx(_components.p, {
        children: "您的浏览器不支持视频标签。"
      })]
    }), "\n", _jsx(_components.h2, {
      children: "Figma的使用场景"
    }), "\n", _jsx(_components.p, {
      children: "要做一个自己的产品，在哪里会用到 Figma 呢？我们并不需要会用Figma的所有功能，我这里总结了几个场景，大家可以参考一下，视频中也会做几个案例，会用这些就够了。"
    }), "\n", _jsx(_components.h3, {
      children: "1. Logo设计"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsx(_components.li, {
        children: "Favicon导出(favicon generator)"
      }), "\n", _jsx(_components.li, {
        children: "网站中的logo素材"
      }), "\n"]
    }), "\n", _jsx(_components.h3, {
      children: "2. 网站开发会用到的图片素材"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsx(_components.li, {
        children: "OG Image 设计"
      }), "\n", _jsx(_components.li, {
        children: "产品的市场截图设计"
      }), "\n", _jsx(_components.li, {
        children: "网站中的图片素材输出"
      }), "\n", _jsx(_components.li, {
        children: "使用 Mockup 输出图片"
      }), "\n", _jsx(_components.li, {
        children: "抠图(background remover)"
      }), "\n", _jsx(_components.li, {
        children: "改变尺寸导出(导出用户头像，产品截图等)"
      }), "\n", _jsx(_components.li, {
        children: "WebP Exporter"
      }), "\n"]
    }), "\n", _jsx(_components.h2, {
      children: "官方教程"
    }), "\n", _jsx(_components.p, {
      children: "也许市面上有很多人推荐的 Figma 教程五花八门，但大道至简，很多人都会忽略一个学习资源 —— 官方的学习文档与教程。对于新手学习 Figma，其实官方的教程就足够了。"
    }), "\n", _jsxs(_components.p, {
      children: ["你可以访问 ", _jsx(_components.a, {
        href: "https://www.figma.com/resource-library/",
        children: "Figma Resource Library"
      }), " 获取官方的学习资源，这里提供了全面的学习材料，从基础到进阶的内容应有尽有。"]
    }), "\n", _jsx(_components.p, {
      children: "点击路径如下：官网下拉到底，在「资源」-「设计学习」中就能够看到课程。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/e3275d5a1f3f47a3b4e4a11756b3831f.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7d5e4c2b1c404e7285c8d68eb726fb75.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h2, {
      children: "小白的Figma入门手册(南山可-站酷ZCOOL)"
    }), "\n", _jsx(_components.p, {
      children: "URL Source: https://www.zcool.com.cn/article/ZMTE5MzAwNA==.html?"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/bbaa39961e764e2587c1c044350837cc.jpg",
        alt: ""
      })
    }), "\n", _jsx(_components.h2, {
      children: "一、figma基础介绍"
    }), "\n", _jsx(_components.h3, {
      children: "Figma界面介绍"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/e861cf275029485093f2ce41087fe43c.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "Figma基础界面与常规设计软件没有太多差异，有Sketch使用经验的用户几乎可以无缝衔接到Figma上。"
    }), "\n", _jsx(_components.h3, {
      children: "顶部导航栏"
    }), "\n", _jsx(_components.p, {
      children: "顶部为导航栏，已打开的所有文档都会在这里展示，左侧Figma icon为Home键，点击回到团队主页，右侧导航Tab可以通过快捷键Command+123切换，这里的快捷键和Sketch查看全部视图的快捷键相冲突。而在Figma中，查看全部视图的快捷键是Shift+1，查看目标视图到全图大小的快捷键为Shift+2。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/d6a9274818d646b9bcd0a98bfe7d95bb.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "工具栏"
    }), "\n", _jsx(_components.p, {
      children: "基础工具栏与Sketch几乎无任何区别，从左至右分别为，移动、画板、矩形工具、钢笔工具、文字工具、视图工具、评论。而右侧功能则倾向于导出协作类操作，如Share类似蓝湖上传标注的功能，播放键则是用于运行交互原型的入口。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/257a82193d8846e7803fac66d5e5500b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "图层组件"
    }), "\n", _jsx(_components.p, {
      children: "左侧为常见的图层导航栏，可通过顶部在图层和组件两个模块间切换，上图中展示了图层树中不同元素的缩略图样式，其中组件和实例比较特殊，简单理解，实例是组件的复制体，需要注意的是，组件不可逆，而实例是可以逆向为Grop的，也就是取消组件化。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/1402341031ce47b9b3cf69a11dcb274b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "属性检查器"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/b0fa495194334019a4a0409d1735d191.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "帮助功能"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/fc3d2741df9040cdbb892a3c19ae1e85.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Figma基础功能"
    }), "\n", _jsx(_components.h3, {
      children: "画板 Frames"
    }), "\n", _jsx(_components.p, {
      children: "建立画板有两种常用方式。常规方式是通过快捷键F或点击工具栏画板工具来手动建立。另外一种比较自由的方式是基于选中元素创建画板。在圈中一组元素后，右键选项面板中有Frame Selection的选项和Grop Selection的选项，两者分别是建立画板和建立组，从这里也可以看出来，Figma中组Grop和画板Frame是相关性较大，较相似的概念，且在实际场景中，画板和组可以进行切换。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/5fa8311d1c0d483dbebcce7bb4fe9b38.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "Frame包含Grop，Grop单纯的代表对一些元素的打包与整合，与常规设计软件中的组的概念无异，但Frame则更强调导出与自动布局、组件化等方面。例如你要将一个消息气泡组件化后，会发现其属性自动由Grop转化为Frame。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/f6ef3ba099994f63b5c9deeb20623be6.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "文字工具和字体"
    }), "\n", _jsx(_components.p, {
      children: "文字工具可以通过快捷键T快速唤醒，交互与PS近似，单击键入常规文字框，框选键入固定范围文字框。Figma的字体工具与Sketch差异点在于其共享样式，文字系统是一套设计系统的核心组成元素之一，而在Figma中，文字的样式被拆解为字体样式（涉及到文字字号、字族、字重）和颜色填充样式（颜色填充样式适用于所有元素）。"
    }), "\n", _jsx(_components.p, {
      children: "另外要提醒的一点是，Figma字距等属性默认使用百分比来界定，但它也支持常规的px形式，只需要在调整框键入你需要的值，如150%，或28px，系统会自动匹配到该类计算方式。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/e54a4fa350d249618fcc17132312650a.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "投影与模糊"
    }), "\n", _jsx(_components.p, {
      children: "属性检查器中的effect模块包含投影和模糊两部分。与Sketch完全一致，投影依靠XY和范围、透明度等属性来控制，背景模糊通过调整覆盖层Fill透明度控制，嗯，与sketch完全一致。 在由sketch迁移至figma过程会出现投影还原问题，实际上是某个开关设置的问题，只需要取消勾选Clip content."
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/fae57af8bf764fe2ac802ff5d642f5f6.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "布局栅格"
    }), "\n", _jsx(_components.p, {
      children: "Figma的栅格可以很方便的在画板的属性检查器开启，寻找到Layout Grid并开启它，其中包含常用的栅格与网格两种规范方式。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/c8ffaafad4c845a59ac080c12afeb66c.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "遮罩蒙版"
    }), "\n", _jsx(_components.p, {
      children: "遮罩工具有两个入口，一是选中要运算的图形后，在顶部工具栏的中间区域点击遮罩工具，一是右键菜单中点击 Use as mask选项。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/f29880e91b3b4704b7a5058cc90369c5.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "颜色取色器"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7275a75aca314620bf70b9ebb8a5ad8d.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "布尔运算"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/60a3742ddbd4451782cb502ce9c1d84e.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Figma常用快捷键"
    }), "\n", _jsx(_components.p, {
      children: "这里只统计一些特殊的、容易与sketch起冲突需要刻意记忆的、特别常用的快捷键。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/a0e09fcc3c0c4a76bd1f7d27e07d161e.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Shift+1 Shift+2"
    }), "\n", _jsx(_components.p, {
      children: "常用的放大视图工具，适用于快速查看文件全览，及快速放大某个元素的场景。"
    }), "\n", _jsx(_components.h3, {
      children: "Z+鼠标左键"
    }), "\n", _jsx(_components.p, {
      children: "按住Z快捷键，鼠标会转变为放大镜，此时单击放大视图，同时按住Option会缩小时图。拖拽一片区域则会放大该区域。"
    }), "\n", _jsx(_components.h3, {
      children: "Option+鼠标左键"
    }), "\n", _jsx(_components.p, {
      children: "Figma的右侧属性检查器无法快捷hover在属性值上拖动（需要谨慎的将鼠标移动到属性icon"
    }), "\n", _jsx(_components.p, {
      children: "上），此时可以按住Option再把鼠标Hover到属性框，此时便可以直接拖动调整数值。"
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+G/Cmd+Option+G"
    }), "\n", _jsx(_components.p, {
      children: "从内容打组/从内容新建画板,Figma中组和画板有很多重合的地方，与Sketch差异较大，组还是那个组，但画板可以嵌套画板， 后面会具体解释。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/17df46118dc44b288da0a5de34b7755a.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+鼠标左键"
    }), "\n", _jsx(_components.p, {
      children: "该操作可忽略画板内元素直接调整画板尺寸，适用于画板内元素未做自动布局处理，同时需要调整画板尺寸的场景，直接调整画板尺寸会使图形变形。"
    }), "\n", _jsx(_components.h3, {
      children: "Option+L"
    }), "\n", _jsx(_components.p, {
      children: "该操作可以快速收起图层，在设计过程中使用频率较高，便于高效整理图层。点击空白区执行该命令会收起所有图层，点击某个组或某个画板会收起该组或画板。注意，点击单个图层或元素无效果。"
    }), "\n", _jsx(_components.h3, {
      children: "Shift+H & Shift + V"
    }), "\n", _jsx(_components.p, {
      children: "左右翻转&上下翻转,快捷执行翻转操作，此功能使用场景较多，常规操作需要右键唤醒功能面板然后寻找到目标再执行命令，学会快捷键后可以大大提升翻转操作的效率。"
    }), "\n", _jsx(_components.h3, {
      children: "Shift+R"
    }), "\n", _jsx(_components.p, {
      children: "显示隐藏标尺，使用Sketch的用户需要克服该快捷键的使用习惯，sketch中该操作为Cmd+R。"
    }), "\n", _jsx(_components.h3, {
      children: "Control+G"
    }), "\n", _jsx(_components.p, {
      children: "显示隐藏网格，实际上不仅仅是网格工具，该快捷键唤醒的是栅格工具集合，需要在右侧属性检查器进行调整，可从网格工具转化为栅格工具，默认是网格工具。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/f7759bac93f1435092ea7a28f9a378cc.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "如何复制形状属性"
      })
    }), "\n", _jsx(_components.p, {
      children: "与Sketch相比，Figma为了保证组件化和共享样式的细分程度，将图形的属性样式进行了更细致的拆分，如图形颜色、描边属性，字体字族、字体颜色等属性是分开处理的。因此无法像sketch或PS那样一键复制所有属性，而是需要单独选择某个属性，然后复制。"
    }), "\n", _jsx(_components.p, {
      children: "因此在遇到样式相关的问题时，可以考虑使用共享样式来实现，这也是figma官方期望设计师养成的习惯。"
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+E"
    }), "\n", _jsx(_components.p, {
      children: "扩展图形，在Figma中，图形布尔运算后会保留所有原始图形，在选择图形时经常会选择到布尔前的图形，影响工作效率，在确认图形不会进行二次编辑时，可以考虑直接Command + E将图形扩展为新图形。"
    }), "\n", _jsx(_components.p, {
      children: "如果记不住快捷键，可以右键在选项面板中选择\"Flatten\"进行扩展图形。"
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+Shift+O"
    }), "\n", _jsx(_components.p, {
      children: "扩展描边,在使用描边绘制Icon时，需要通过扩展描边来转为可编辑图形。"
    }), "\n", _jsx(_components.p, {
      children: "如果记不住快捷键，可以右键在选项面板中选择\"Outline Stroke\"进行扩展。"
    }), "\n", _jsx(_components.p, {
      children: "最后，需要查看所有快捷键只需要在右下角唤醒帮助功能，面板中第二个选项Keyboard Shortcuts就是快捷键演示。"
    }), "\n", _jsx(_components.h2, {
      children: "二、Figma进阶功能"
    }), "\n", _jsx(_components.h3, {
      children: "组件（components）"
    }), "\n", _jsx(_components.p, {
      children: "组件和实例：组件是母体，实例是复制体，组件可以删除和修改，不可逆向为组，实例不可直接编辑，但可以逆向为组，然后修改。没有一个固定位置用来存放组件，你最初组件化的那个组，就是唯一的组件母体，且组件不会被收起在一个组件页中，而是存在原本的位置。"
    }), "\n", _jsx(_components.p, {
      children: "组件和实例是分开的，简单理解就是，你最初设计的一个元素，通过Component功能打包为组件A，这个组件就是原始组件A，此时在左侧assert模块下就会存在一个固定组件(类似组件库模块)，当你从Assert模块中拖动出来一个新的组件A，或者从原始组件A复制一个新的组件A，这个新的组件A就是实例，实例可以被还原为组。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/83e5212a1e3f464ba1d47c98039bffe0.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "如何找到最初的组件？"
    }), "\n", _jsx(_components.p, {
      children: "首先需要说明，Figma的组件管理方式很灵活，但相较于Sketch的确不够规范，这里仍建议设计师新建一个layers,以组件来命名，将原始组件都放置在这个页面，易于管理。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/da59b32ac71e433abc9535f71b99d9f8.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "该Layer主要目的在于管理原始组件，例如当需要大批量修改组件时，切换到组件Layer快速修改，修改后快速映射到所有设计稿。"
    }), "\n", _jsx(_components.p, {
      children: "当需要调用组件时，则推荐使用官方提供的Assert模块，通过拖拽调用组件实例。"
    }), "\n", _jsx(_components.p, {
      children: "在实际工作场景中，我们需要从实例跳转到原始组件，以进行大批量效果修改时，可通过属性检查器中的组件icon快捷跳转至原始组件。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/6bbc54abab7b4a17a14ab3ad989254d0.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "实例操作"
    }), "\n", _jsx(_components.p, {
      children: "在实际工作中，我们会遇到使用一个类似组件来建立新组件的场景，此时需要将组件逆向为组，然后进行编辑，在Figma中仅实例可以进行逆向，方法是右键，或者在属性检查器区域执行Detach instance命令。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/1f330d1536154c38b96fececb4cf15bf.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "当直接在当前正在操作的实例上进行少量变更后，可以通过覆盖功能将当前的属性同步给组件和所有实例。"
    }), "\n", _jsx(_components.p, {
      children: "方法是在右侧属性检查器执行Push Overrides to Main Components。"
    }), "\n", _jsx(_components.h3, {
      children: "组件库的使用"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "如何上传和维护组件库？"
      })
    }), "\n", _jsx(_components.p, {
      children: "Figma的组件库系统极其友好，易于维护。设计师只需要将已经设计完成的组件系统和样式系统放置在一个文件中，然后就可以基于当前的文件已有的样式和组件直接建立共享组件库，只需要在Assert的Library入口进入组件窗口，通过组件库窗口中的上传（Publish）功能,完成上传，团队成员就能获得该组件库内容。"
    }), "\n", _jsx(_components.p, {
      children: "后续维护组件库的工作只需要在该文件上进行修改和完善，随后回到library窗口进行更新。当你更新组件库后，其他使用了该组件库内容的设计师会同步收到更新消息，且可以快速同步到最新版本，以保证设计一致性。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "如何使用团队成员已上传的组件库?"
      })
    }), "\n", _jsx(_components.p, {
      children: "在Library窗口，团队已公开的组件库会以List的形式展示，设计师只需要点击你的目标组件库左侧的switch，即可唤醒该组件库，回到你的文件画板中，此时即可调用该组件库的内容，如组件、颜色样式、字体系统等。"
    }), "\n", _jsx(_components.p, {
      children: "想要快速查看组件库内的内容可以使用Option+2，快速调起Assert资源窗口，在左侧图层列表查看。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/8037c264a819449f8d314d5d9421c236.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "响应式约束（constraints）"
    }), "\n", _jsx(_components.p, {
      children: "通过约束功能的官方定义我们更容易理解这个功能。首先要说明其限制条件，约束功能只有在Frame中才可以发挥作用，也只有Frame中的元素，才会展示Constraints工具。因此，官方定义其为：\"允许你将设计元素固定在父框架的不同位置\"，所以，请谨记约束功能以建立Frame为前提，而其主流使用场景就是构建流畅的布局以适应不同设备尺寸，即当设计师将Frame尺寸进行变更时，Frame内的元素会自动按照预先设定的规则固定位置。"
    }), "\n", _jsx(_components.p, {
      children: "但在真实场景下，响应式约束的功能并不局限于此，它更是可复用、可快速编辑组件的必要组成条件。Figma的Frame不同于Sketch的画板工具，可以互相嵌套且不会影响到复杂度产生墒增的问题，因此可以通过Constraints配合Frame组合成规范布局的组件系统，再加上我们后面要讲的Auto layout功能，可以构建出高自由度，可任意调用，且能够根据真实填充数据自动布局的超级组件，这样构建的组件一方面还原了真实场景下的设计效果，一方面大大减少了设计师重复性工作。"
    }), "\n", _jsx(_components.p, {
      children: "下面是响应式约束的不同条件及对应的效果。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/786b931f43bf4a6d93facdc3238e7110.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/087552520a4447d5a87cd5ec34c9bb5c.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "响应式约束的常规案例。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/c700f33931444ad2a5ea7d0060558f94.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "自动化布局（Auto layout）"
    }), "\n", _jsx(_components.p, {
      children: "自动化布局工具是制作复杂组件的核心技巧，与响应式约束搭配可以设计出高度自由可编辑的组件乃至半成品页面。"
    }), "\n", _jsxs(_components.p, {
      children: ["一般来说，我们谈到组件系统主要聚焦的是其规范一致性，设计资源管理等方面，", _jsx(_components.strong, {
        children: "但实际上，组件库在提升设计师效率，减少重复性工作方面能够发挥更强大的作用"
      }), "。常规组件调用后需要花费一定精力修改，但通过自动化布局工具设定好规则后，设计师能沉淀一整套可直接使用、根据内容填充物自动布局变化的超级组件，甚至是成熟的典型页面，可极大提升设计效率，减少在移动、复制、填充内容等基础操作上的时间浪费。"]
    }), "\n", _jsx(_components.p, {
      children: "下面我实现了一个最简单的案例，再该search组件中需要填充真实数据以模拟真实场景下的样式，设计师只需要输入新的填充内容，组件内其他元素会自动匹配到对应的正确位置。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/50fbc78c398c46f2a4d98735e4de913e.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "自动布局按照常规布局规则划分为三个属性，分别是左右空隙、上下空隙、元素间空隙。"
    }), "\n", _jsx(_components.p, {
      children: "当选中多个元素，执行Shift+A（建议熟悉快捷键提升效率）后，会为这些元素建立自动布局，规则可以在右侧属性检查区设定。"
    }), "\n", _jsx(_components.p, {
      children: "例如我需要建立一组横排的card，此时可以先设计好三个card，然后选中它们，执行Shift+A即可创建一组横排的自动布局（横排竖排根据你真实场景下元素的排列情况，也可以在右侧更改横排为竖排）。另外一种小技巧是，直接给一个card执行Shift+A命令，然后选中组内的card执行复制命名cmd+D，后复制出的每一个card也会按照预定规则排列。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/2879f9feaf984ce6825993745d08b938.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "如下图案例所示，元素与元素组合构成自动布局的组件，自动布局的组件组合则能构成更复杂的大兴组件乃至典型模块、典型页面。建议设计师快速掌握该技巧的方法是将其套入实际需求中，从提升设计效率，减少重复工作的出发点开始设计自己的典型组件模块。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/2d3b92c2010248e9b56ae03193edb452.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7a636154645843929e85430a2a8ec2de.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "共享样式 （style）"
    }), "\n", _jsx(_components.p, {
      children: "关于共享样式，从sketch转型到Figma的同学应该再熟悉不过了，共享样式是组件库的核心构成之一，主要包括颜色、字体及各种样式效果。这里着重说明一下Figma共享样式与Sketch共享样式的差异。Figma中对样式进行了更为细致的划分，共包括颜色、字体、效果三类。"
    }), "\n", _jsx(_components.p, {
      children: "以颜色为例，Figma中颜色样式可自由运用到图形、描边、字体等各细分元素上面，无任何限制，可与各元素自由搭配。以字体为例，字体样式仅包括字体字号、字重、行高等字体本身的属性，不包括颜色，换言之，Font样式的颜色可以自由使用Color样式。"
    }), "\n", _jsx(_components.p, {
      children: "概括来讲，Sketch更注重常规理解下，组件系统的实际应用时的场景，如字体样式是由字体字族、字号、字重、行高、颜色所有属性一同构成的，而Figma强调更高的自由和编辑性，孰优孰劣无法一言蔽之，从严谨性和组件自我封闭完整性来讲，sketch的要更好一些，但从组件自由度，组件嵌套组合的效率上来讲Figma要更好一些，所以关键在于设计师能否合理运用，快速掌握技巧并提高效率。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7a262df5872b4a62baffaaf87b5498a9.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "交互原型"
    }), "\n", _jsx(_components.p, {
      children: "Figma的交互功能，在设计软件中我愿称之为最强，极简的操作逻辑以及优秀的实现效果使其在中小复杂度的交互场景下不逊色于专业UI动效设计软件。在FIgma的交互模式下能看到Principle的影子，其背后的设计逻辑高度相似，符合UI设计领域快速输出产品交互物的场景。"
    }), "\n", _jsx(_components.p, {
      children: "如下图所示，界面间的交互逻辑通过选择起始画板或其中的元素然后简单的连线即可完成。当然，如果设计师不满足于此可以在右侧属性检查器制作更精致的过度效果。Figma拥有者完善的交互手势可供设计师选择，如点击、hover、拖拽等。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/0bac6d0aa0ce4048bfa7133a199dfcca.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "然后是过渡效果，在这里我只推荐一种交互方式，那就是Smart Animate，一句话概括，Smart Animate复刻了Principle元素演变的逻辑，所以如果你是Principle的忠实拥趸，那在FIgma交互模式下你可以无缝代入到Principle的使用经验中。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/9ce0ffb2a2b84202a6071f1f641e7c0b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "除此之外，需要特殊说明的一个交互功能是弹窗交互Open Overly。使用该交互会调起一个覆盖层，适合弹窗类场景。方法如下图所示。Figma交互模块有很多功能，感兴趣的可以自行探索，而对于大部分设计师来讲，掌握最基础的Figma交互原型功能就已经能够让你的演示事半功倍了。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/84666e4083294a85aeaaf81802a2f087.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "输出"
    }), "\n", _jsx(_components.p, {
      children: "直接分享链接给对应的利益相关者即可。PM可以在视觉稿上直接评论，快捷沟通解决问题。开发可以切换到开发者模式查看切图标注。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/cf1337733d1745f69da99291f289de76.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "插件"
    }), "\n", _jsx(_components.p, {
      children: "Figma与Sketch一样有众多插件可以帮助设计师提升设计效率，甚至某些基础功能如等比缩放也需要插件帮助实现。"
    }), "\n", _jsx(_components.p, {
      children: "插件可以通过系统菜单中的Plugin来安装和调用。具体位置为Plugin-manage plugin。想要搜索新的插件只需要点开一个已安装插件，在插件详情页的顶部使用搜索工具来寻找目标插件。"
    }), "\n", _jsx(_components.p, {
      children: "下面列出了几个我最常用的插件。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Arrow Auto"
      })
    }), "\n", _jsx(_components.p, {
      children: "Arrow Auto是一个原型连线工具，能够快速在选中的元素、画板间连线，且可以自由选择线段两端的样式。由于Figma官方的交互连接线需要在Protype模式下才可以查看，存在无法覆盖的场景。"
    }), "\n", _jsx(_components.p, {
      children: "因此当设计师需要快速展示交互逻辑时，Arrow Auto是一个不错的选择，。除此之外，需要输出中低保真度原型的交互设计师和PM也可以使用它来快速构建MVP原型。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/9dbf36bac8964b3a8afcdcdfc82f2385.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Time machine"
      })
    }), "\n", _jsx(_components.p, {
      children: "TIme machine是一款时间机器类插件，可以帮助设计师快速储存历史版本设计稿，并通过时间线命名。虽然Figma自带30天可追述历史版本的功能，但保存一份备份版文件还是有其必要性的。"
    }), "\n", _jsx(_components.p, {
      children: "设计师只需要选择对应的画板，执行plugin-TIme machine，就会自动生成一个以时间命名的Layer，用来存放历史备份。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/341631ed3c9f4776b6157ba92f2d275b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Clean Document"
      })
    }), "\n", _jsx(_components.p, {
      children: "Clean Document是一款图层清理插件，可以帮助设计师快速清理隐藏的图层，解除单个图层的分组，批量规范图层命名等。设计师可以在插件页面中选择自己需要执行的清理工作，然后执行清理操作，期间需要花费一定时间，为了避免卡顿可以少量选中画板分批清理。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/be091eab2fe84765af23383857cbf3b7.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Scale"
      })
    }), "\n", _jsx(_components.p, {
      children: "Scale是一款等比缩放插件。由于Figma自带的等比缩放功能无法精确按照数值进行操作，因此当设计师需要对设计元素进行等比缩放时，需要适用该插件。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/3d410ca0b6304e228c1b5c60d872f6ea.png",
        alt: ""
      })
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = props.components || ({});
  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {
    children: _jsx(_createMdxContent, props)
  })) : _createMdxContent(props);
}
return { default: MDXContent };f:T8ca6,const _jsx = _jsx_runtime.jsx;
const _jsxs = _jsx_runtime.jsxs;
const _Fragment = _jsx_runtime.Fragment;
function _createMdxContent(props) {
  const _components = Object.assign({
    h1: "h1",
    h2: "h2",
    p: "p",
    strong: "strong",
    h3: "h3",
    ul: "ul",
    li: "li",
    a: "a",
    img: "img"
  }, props.components);
  return _jsxs(_Fragment, {
    children: [_jsx(_components.h1, {
      children: "2.3 🎨 Figma: UI设计"
    }), "\n", _jsx(_components.h2, {
      children: "Figma 入门手册"
    }), "\n", _jsx(_components.p, {
      children: "官方网站：https://www.figma.com/"
    }), "\n", _jsxs(_components.p, {
      children: [_jsx(_components.strong, {
        children: "Figma 是一个专业的 UI/UX 设计工具"
      }), "，作为一个基于浏览器的设计工具，它让设计变得更加高效和协作。"]
    }), "\n", _jsx(_components.p, {
      children: "既然是新手学习 Figma 教程，那么优先学会基础才是关键。"
    }), "\n", _jsxs("video", {
      controls: true,
      width: "100%",
      style: {
        maxWidth: '800px'
      },
      children: [_jsx("source", {
        src: "https://minio.xiaofeng.show/ai-code/2.3.mp4",
        type: "video/mp4"
      }), _jsx(_components.p, {
        children: "您的浏览器不支持视频标签。"
      })]
    }), "\n", _jsx(_components.h2, {
      children: "Figma的使用场景"
    }), "\n", _jsx(_components.p, {
      children: "要做一个自己的产品，在哪里会用到 Figma 呢？我们并不需要会用Figma的所有功能，我这里总结了几个场景，大家可以参考一下，视频中也会做几个案例，会用这些就够了。"
    }), "\n", _jsx(_components.h3, {
      children: "1. Logo设计"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsx(_components.li, {
        children: "Favicon导出(favicon generator)"
      }), "\n", _jsx(_components.li, {
        children: "网站中的logo素材"
      }), "\n"]
    }), "\n", _jsx(_components.h3, {
      children: "2. 网站开发会用到的图片素材"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsx(_components.li, {
        children: "OG Image 设计"
      }), "\n", _jsx(_components.li, {
        children: "产品的市场截图设计"
      }), "\n", _jsx(_components.li, {
        children: "网站中的图片素材输出"
      }), "\n", _jsx(_components.li, {
        children: "使用 Mockup 输出图片"
      }), "\n", _jsx(_components.li, {
        children: "抠图(background remover)"
      }), "\n", _jsx(_components.li, {
        children: "改变尺寸导出(导出用户头像，产品截图等)"
      }), "\n", _jsx(_components.li, {
        children: "WebP Exporter"
      }), "\n"]
    }), "\n", _jsx(_components.h2, {
      children: "官方教程"
    }), "\n", _jsx(_components.p, {
      children: "也许市面上有很多人推荐的 Figma 教程五花八门，但大道至简，很多人都会忽略一个学习资源 —— 官方的学习文档与教程。对于新手学习 Figma，其实官方的教程就足够了。"
    }), "\n", _jsxs(_components.p, {
      children: ["你可以访问 ", _jsx(_components.a, {
        href: "https://www.figma.com/resource-library/",
        children: "Figma Resource Library"
      }), " 获取官方的学习资源，这里提供了全面的学习材料，从基础到进阶的内容应有尽有。"]
    }), "\n", _jsx(_components.p, {
      children: "点击路径如下：官网下拉到底，在「资源」-「设计学习」中就能够看到课程。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/e3275d5a1f3f47a3b4e4a11756b3831f.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7d5e4c2b1c404e7285c8d68eb726fb75.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h2, {
      children: "小白的Figma入门手册(南山可-站酷ZCOOL)"
    }), "\n", _jsx(_components.p, {
      children: "URL Source: https://www.zcool.com.cn/article/ZMTE5MzAwNA==.html?"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/bbaa39961e764e2587c1c044350837cc.jpg",
        alt: ""
      })
    }), "\n", _jsx(_components.h2, {
      children: "一、figma基础介绍"
    }), "\n", _jsx(_components.h3, {
      children: "Figma界面介绍"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/e861cf275029485093f2ce41087fe43c.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "Figma基础界面与常规设计软件没有太多差异，有Sketch使用经验的用户几乎可以无缝衔接到Figma上。"
    }), "\n", _jsx(_components.h3, {
      children: "顶部导航栏"
    }), "\n", _jsx(_components.p, {
      children: "顶部为导航栏，已打开的所有文档都会在这里展示，左侧Figma icon为Home键，点击回到团队主页，右侧导航Tab可以通过快捷键Command+123切换，这里的快捷键和Sketch查看全部视图的快捷键相冲突。而在Figma中，查看全部视图的快捷键是Shift+1，查看目标视图到全图大小的快捷键为Shift+2。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/d6a9274818d646b9bcd0a98bfe7d95bb.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "工具栏"
    }), "\n", _jsx(_components.p, {
      children: "基础工具栏与Sketch几乎无任何区别，从左至右分别为，移动、画板、矩形工具、钢笔工具、文字工具、视图工具、评论。而右侧功能则倾向于导出协作类操作，如Share类似蓝湖上传标注的功能，播放键则是用于运行交互原型的入口。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/257a82193d8846e7803fac66d5e5500b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "图层组件"
    }), "\n", _jsx(_components.p, {
      children: "左侧为常见的图层导航栏，可通过顶部在图层和组件两个模块间切换，上图中展示了图层树中不同元素的缩略图样式，其中组件和实例比较特殊，简单理解，实例是组件的复制体，需要注意的是，组件不可逆，而实例是可以逆向为Grop的，也就是取消组件化。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/1402341031ce47b9b3cf69a11dcb274b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "属性检查器"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/b0fa495194334019a4a0409d1735d191.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "帮助功能"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/fc3d2741df9040cdbb892a3c19ae1e85.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Figma基础功能"
    }), "\n", _jsx(_components.h3, {
      children: "画板 Frames"
    }), "\n", _jsx(_components.p, {
      children: "建立画板有两种常用方式。常规方式是通过快捷键F或点击工具栏画板工具来手动建立。另外一种比较自由的方式是基于选中元素创建画板。在圈中一组元素后，右键选项面板中有Frame Selection的选项和Grop Selection的选项，两者分别是建立画板和建立组，从这里也可以看出来，Figma中组Grop和画板Frame是相关性较大，较相似的概念，且在实际场景中，画板和组可以进行切换。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/5fa8311d1c0d483dbebcce7bb4fe9b38.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "Frame包含Grop，Grop单纯的代表对一些元素的打包与整合，与常规设计软件中的组的概念无异，但Frame则更强调导出与自动布局、组件化等方面。例如你要将一个消息气泡组件化后，会发现其属性自动由Grop转化为Frame。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/f6ef3ba099994f63b5c9deeb20623be6.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "文字工具和字体"
    }), "\n", _jsx(_components.p, {
      children: "文字工具可以通过快捷键T快速唤醒，交互与PS近似，单击键入常规文字框，框选键入固定范围文字框。Figma的字体工具与Sketch差异点在于其共享样式，文字系统是一套设计系统的核心组成元素之一，而在Figma中，文字的样式被拆解为字体样式（涉及到文字字号、字族、字重）和颜色填充样式（颜色填充样式适用于所有元素）。"
    }), "\n", _jsx(_components.p, {
      children: "另外要提醒的一点是，Figma字距等属性默认使用百分比来界定，但它也支持常规的px形式，只需要在调整框键入你需要的值，如150%，或28px，系统会自动匹配到该类计算方式。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/e54a4fa350d249618fcc17132312650a.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "投影与模糊"
    }), "\n", _jsx(_components.p, {
      children: "属性检查器中的effect模块包含投影和模糊两部分。与Sketch完全一致，投影依靠XY和范围、透明度等属性来控制，背景模糊通过调整覆盖层Fill透明度控制，嗯，与sketch完全一致。 在由sketch迁移至figma过程会出现投影还原问题，实际上是某个开关设置的问题，只需要取消勾选Clip content."
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/fae57af8bf764fe2ac802ff5d642f5f6.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "布局栅格"
    }), "\n", _jsx(_components.p, {
      children: "Figma的栅格可以很方便的在画板的属性检查器开启，寻找到Layout Grid并开启它，其中包含常用的栅格与网格两种规范方式。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/c8ffaafad4c845a59ac080c12afeb66c.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "遮罩蒙版"
    }), "\n", _jsx(_components.p, {
      children: "遮罩工具有两个入口，一是选中要运算的图形后，在顶部工具栏的中间区域点击遮罩工具，一是右键菜单中点击 Use as mask选项。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/f29880e91b3b4704b7a5058cc90369c5.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "颜色取色器"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7275a75aca314620bf70b9ebb8a5ad8d.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "布尔运算"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/60a3742ddbd4451782cb502ce9c1d84e.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Figma常用快捷键"
    }), "\n", _jsx(_components.p, {
      children: "这里只统计一些特殊的、容易与sketch起冲突需要刻意记忆的、特别常用的快捷键。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/a0e09fcc3c0c4a76bd1f7d27e07d161e.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Shift+1 Shift+2"
    }), "\n", _jsx(_components.p, {
      children: "常用的放大视图工具，适用于快速查看文件全览，及快速放大某个元素的场景。"
    }), "\n", _jsx(_components.h3, {
      children: "Z+鼠标左键"
    }), "\n", _jsx(_components.p, {
      children: "按住Z快捷键，鼠标会转变为放大镜，此时单击放大视图，同时按住Option会缩小时图。拖拽一片区域则会放大该区域。"
    }), "\n", _jsx(_components.h3, {
      children: "Option+鼠标左键"
    }), "\n", _jsx(_components.p, {
      children: "Figma的右侧属性检查器无法快捷hover在属性值上拖动（需要谨慎的将鼠标移动到属性icon"
    }), "\n", _jsx(_components.p, {
      children: "上），此时可以按住Option再把鼠标Hover到属性框，此时便可以直接拖动调整数值。"
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+G/Cmd+Option+G"
    }), "\n", _jsx(_components.p, {
      children: "从内容打组/从内容新建画板,Figma中组和画板有很多重合的地方，与Sketch差异较大，组还是那个组，但画板可以嵌套画板， 后面会具体解释。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/17df46118dc44b288da0a5de34b7755a.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+鼠标左键"
    }), "\n", _jsx(_components.p, {
      children: "该操作可忽略画板内元素直接调整画板尺寸，适用于画板内元素未做自动布局处理，同时需要调整画板尺寸的场景，直接调整画板尺寸会使图形变形。"
    }), "\n", _jsx(_components.h3, {
      children: "Option+L"
    }), "\n", _jsx(_components.p, {
      children: "该操作可以快速收起图层，在设计过程中使用频率较高，便于高效整理图层。点击空白区执行该命令会收起所有图层，点击某个组或某个画板会收起该组或画板。注意，点击单个图层或元素无效果。"
    }), "\n", _jsx(_components.h3, {
      children: "Shift+H & Shift + V"
    }), "\n", _jsx(_components.p, {
      children: "左右翻转&上下翻转,快捷执行翻转操作，此功能使用场景较多，常规操作需要右键唤醒功能面板然后寻找到目标再执行命令，学会快捷键后可以大大提升翻转操作的效率。"
    }), "\n", _jsx(_components.h3, {
      children: "Shift+R"
    }), "\n", _jsx(_components.p, {
      children: "显示隐藏标尺，使用Sketch的用户需要克服该快捷键的使用习惯，sketch中该操作为Cmd+R。"
    }), "\n", _jsx(_components.h3, {
      children: "Control+G"
    }), "\n", _jsx(_components.p, {
      children: "显示隐藏网格，实际上不仅仅是网格工具，该快捷键唤醒的是栅格工具集合，需要在右侧属性检查器进行调整，可从网格工具转化为栅格工具，默认是网格工具。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/f7759bac93f1435092ea7a28f9a378cc.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "如何复制形状属性"
      })
    }), "\n", _jsx(_components.p, {
      children: "与Sketch相比，Figma为了保证组件化和共享样式的细分程度，将图形的属性样式进行了更细致的拆分，如图形颜色、描边属性，字体字族、字体颜色等属性是分开处理的。因此无法像sketch或PS那样一键复制所有属性，而是需要单独选择某个属性，然后复制。"
    }), "\n", _jsx(_components.p, {
      children: "因此在遇到样式相关的问题时，可以考虑使用共享样式来实现，这也是figma官方期望设计师养成的习惯。"
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+E"
    }), "\n", _jsx(_components.p, {
      children: "扩展图形，在Figma中，图形布尔运算后会保留所有原始图形，在选择图形时经常会选择到布尔前的图形，影响工作效率，在确认图形不会进行二次编辑时，可以考虑直接Command + E将图形扩展为新图形。"
    }), "\n", _jsx(_components.p, {
      children: "如果记不住快捷键，可以右键在选项面板中选择\"Flatten\"进行扩展图形。"
    }), "\n", _jsx(_components.h3, {
      children: "Cmd+Shift+O"
    }), "\n", _jsx(_components.p, {
      children: "扩展描边,在使用描边绘制Icon时，需要通过扩展描边来转为可编辑图形。"
    }), "\n", _jsx(_components.p, {
      children: "如果记不住快捷键，可以右键在选项面板中选择\"Outline Stroke\"进行扩展。"
    }), "\n", _jsx(_components.p, {
      children: "最后，需要查看所有快捷键只需要在右下角唤醒帮助功能，面板中第二个选项Keyboard Shortcuts就是快捷键演示。"
    }), "\n", _jsx(_components.h2, {
      children: "二、Figma进阶功能"
    }), "\n", _jsx(_components.h3, {
      children: "组件（components）"
    }), "\n", _jsx(_components.p, {
      children: "组件和实例：组件是母体，实例是复制体，组件可以删除和修改，不可逆向为组，实例不可直接编辑，但可以逆向为组，然后修改。没有一个固定位置用来存放组件，你最初组件化的那个组，就是唯一的组件母体，且组件不会被收起在一个组件页中，而是存在原本的位置。"
    }), "\n", _jsx(_components.p, {
      children: "组件和实例是分开的，简单理解就是，你最初设计的一个元素，通过Component功能打包为组件A，这个组件就是原始组件A，此时在左侧assert模块下就会存在一个固定组件(类似组件库模块)，当你从Assert模块中拖动出来一个新的组件A，或者从原始组件A复制一个新的组件A，这个新的组件A就是实例，实例可以被还原为组。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/83e5212a1e3f464ba1d47c98039bffe0.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "如何找到最初的组件？"
    }), "\n", _jsx(_components.p, {
      children: "首先需要说明，Figma的组件管理方式很灵活，但相较于Sketch的确不够规范，这里仍建议设计师新建一个layers,以组件来命名，将原始组件都放置在这个页面，易于管理。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/da59b32ac71e433abc9535f71b99d9f8.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "该Layer主要目的在于管理原始组件，例如当需要大批量修改组件时，切换到组件Layer快速修改，修改后快速映射到所有设计稿。"
    }), "\n", _jsx(_components.p, {
      children: "当需要调用组件时，则推荐使用官方提供的Assert模块，通过拖拽调用组件实例。"
    }), "\n", _jsx(_components.p, {
      children: "在实际工作场景中，我们需要从实例跳转到原始组件，以进行大批量效果修改时，可通过属性检查器中的组件icon快捷跳转至原始组件。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/6bbc54abab7b4a17a14ab3ad989254d0.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "实例操作"
    }), "\n", _jsx(_components.p, {
      children: "在实际工作中，我们会遇到使用一个类似组件来建立新组件的场景，此时需要将组件逆向为组，然后进行编辑，在Figma中仅实例可以进行逆向，方法是右键，或者在属性检查器区域执行Detach instance命令。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/1f330d1536154c38b96fececb4cf15bf.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "当直接在当前正在操作的实例上进行少量变更后，可以通过覆盖功能将当前的属性同步给组件和所有实例。"
    }), "\n", _jsx(_components.p, {
      children: "方法是在右侧属性检查器执行Push Overrides to Main Components。"
    }), "\n", _jsx(_components.h3, {
      children: "组件库的使用"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "如何上传和维护组件库？"
      })
    }), "\n", _jsx(_components.p, {
      children: "Figma的组件库系统极其友好，易于维护。设计师只需要将已经设计完成的组件系统和样式系统放置在一个文件中，然后就可以基于当前的文件已有的样式和组件直接建立共享组件库，只需要在Assert的Library入口进入组件窗口，通过组件库窗口中的上传（Publish）功能,完成上传，团队成员就能获得该组件库内容。"
    }), "\n", _jsx(_components.p, {
      children: "后续维护组件库的工作只需要在该文件上进行修改和完善，随后回到library窗口进行更新。当你更新组件库后，其他使用了该组件库内容的设计师会同步收到更新消息，且可以快速同步到最新版本，以保证设计一致性。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "如何使用团队成员已上传的组件库?"
      })
    }), "\n", _jsx(_components.p, {
      children: "在Library窗口，团队已公开的组件库会以List的形式展示，设计师只需要点击你的目标组件库左侧的switch，即可唤醒该组件库，回到你的文件画板中，此时即可调用该组件库的内容，如组件、颜色样式、字体系统等。"
    }), "\n", _jsx(_components.p, {
      children: "想要快速查看组件库内的内容可以使用Option+2，快速调起Assert资源窗口，在左侧图层列表查看。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/8037c264a819449f8d314d5d9421c236.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "响应式约束（constraints）"
    }), "\n", _jsx(_components.p, {
      children: "通过约束功能的官方定义我们更容易理解这个功能。首先要说明其限制条件，约束功能只有在Frame中才可以发挥作用，也只有Frame中的元素，才会展示Constraints工具。因此，官方定义其为：\"允许你将设计元素固定在父框架的不同位置\"，所以，请谨记约束功能以建立Frame为前提，而其主流使用场景就是构建流畅的布局以适应不同设备尺寸，即当设计师将Frame尺寸进行变更时，Frame内的元素会自动按照预先设定的规则固定位置。"
    }), "\n", _jsx(_components.p, {
      children: "但在真实场景下，响应式约束的功能并不局限于此，它更是可复用、可快速编辑组件的必要组成条件。Figma的Frame不同于Sketch的画板工具，可以互相嵌套且不会影响到复杂度产生墒增的问题，因此可以通过Constraints配合Frame组合成规范布局的组件系统，再加上我们后面要讲的Auto layout功能，可以构建出高自由度，可任意调用，且能够根据真实填充数据自动布局的超级组件，这样构建的组件一方面还原了真实场景下的设计效果，一方面大大减少了设计师重复性工作。"
    }), "\n", _jsx(_components.p, {
      children: "下面是响应式约束的不同条件及对应的效果。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/786b931f43bf4a6d93facdc3238e7110.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/087552520a4447d5a87cd5ec34c9bb5c.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "响应式约束的常规案例。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/c700f33931444ad2a5ea7d0060558f94.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "自动化布局（Auto layout）"
    }), "\n", _jsx(_components.p, {
      children: "自动化布局工具是制作复杂组件的核心技巧，与响应式约束搭配可以设计出高度自由可编辑的组件乃至半成品页面。"
    }), "\n", _jsxs(_components.p, {
      children: ["一般来说，我们谈到组件系统主要聚焦的是其规范一致性，设计资源管理等方面，", _jsx(_components.strong, {
        children: "但实际上，组件库在提升设计师效率，减少重复性工作方面能够发挥更强大的作用"
      }), "。常规组件调用后需要花费一定精力修改，但通过自动化布局工具设定好规则后，设计师能沉淀一整套可直接使用、根据内容填充物自动布局变化的超级组件，甚至是成熟的典型页面，可极大提升设计效率，减少在移动、复制、填充内容等基础操作上的时间浪费。"]
    }), "\n", _jsx(_components.p, {
      children: "下面我实现了一个最简单的案例，再该search组件中需要填充真实数据以模拟真实场景下的样式，设计师只需要输入新的填充内容，组件内其他元素会自动匹配到对应的正确位置。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/50fbc78c398c46f2a4d98735e4de913e.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "自动布局按照常规布局规则划分为三个属性，分别是左右空隙、上下空隙、元素间空隙。"
    }), "\n", _jsx(_components.p, {
      children: "当选中多个元素，执行Shift+A（建议熟悉快捷键提升效率）后，会为这些元素建立自动布局，规则可以在右侧属性检查区设定。"
    }), "\n", _jsx(_components.p, {
      children: "例如我需要建立一组横排的card，此时可以先设计好三个card，然后选中它们，执行Shift+A即可创建一组横排的自动布局（横排竖排根据你真实场景下元素的排列情况，也可以在右侧更改横排为竖排）。另外一种小技巧是，直接给一个card执行Shift+A命令，然后选中组内的card执行复制命名cmd+D，后复制出的每一个card也会按照预定规则排列。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/2879f9feaf984ce6825993745d08b938.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "如下图案例所示，元素与元素组合构成自动布局的组件，自动布局的组件组合则能构成更复杂的大兴组件乃至典型模块、典型页面。建议设计师快速掌握该技巧的方法是将其套入实际需求中，从提升设计效率，减少重复工作的出发点开始设计自己的典型组件模块。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/2d3b92c2010248e9b56ae03193edb452.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7a636154645843929e85430a2a8ec2de.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "共享样式 （style）"
    }), "\n", _jsx(_components.p, {
      children: "关于共享样式，从sketch转型到Figma的同学应该再熟悉不过了，共享样式是组件库的核心构成之一，主要包括颜色、字体及各种样式效果。这里着重说明一下Figma共享样式与Sketch共享样式的差异。Figma中对样式进行了更为细致的划分，共包括颜色、字体、效果三类。"
    }), "\n", _jsx(_components.p, {
      children: "以颜色为例，Figma中颜色样式可自由运用到图形、描边、字体等各细分元素上面，无任何限制，可与各元素自由搭配。以字体为例，字体样式仅包括字体字号、字重、行高等字体本身的属性，不包括颜色，换言之，Font样式的颜色可以自由使用Color样式。"
    }), "\n", _jsx(_components.p, {
      children: "概括来讲，Sketch更注重常规理解下，组件系统的实际应用时的场景，如字体样式是由字体字族、字号、字重、行高、颜色所有属性一同构成的，而Figma强调更高的自由和编辑性，孰优孰劣无法一言蔽之，从严谨性和组件自我封闭完整性来讲，sketch的要更好一些，但从组件自由度，组件嵌套组合的效率上来讲Figma要更好一些，所以关键在于设计师能否合理运用，快速掌握技巧并提高效率。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/7a262df5872b4a62baffaaf87b5498a9.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "交互原型"
    }), "\n", _jsx(_components.p, {
      children: "Figma的交互功能，在设计软件中我愿称之为最强，极简的操作逻辑以及优秀的实现效果使其在中小复杂度的交互场景下不逊色于专业UI动效设计软件。在FIgma的交互模式下能看到Principle的影子，其背后的设计逻辑高度相似，符合UI设计领域快速输出产品交互物的场景。"
    }), "\n", _jsx(_components.p, {
      children: "如下图所示，界面间的交互逻辑通过选择起始画板或其中的元素然后简单的连线即可完成。当然，如果设计师不满足于此可以在右侧属性检查器制作更精致的过度效果。Figma拥有者完善的交互手势可供设计师选择，如点击、hover、拖拽等。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/0bac6d0aa0ce4048bfa7133a199dfcca.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "然后是过渡效果，在这里我只推荐一种交互方式，那就是Smart Animate，一句话概括，Smart Animate复刻了Principle元素演变的逻辑，所以如果你是Principle的忠实拥趸，那在FIgma交互模式下你可以无缝代入到Principle的使用经验中。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/9ce0ffb2a2b84202a6071f1f641e7c0b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: "除此之外，需要特殊说明的一个交互功能是弹窗交互Open Overly。使用该交互会调起一个覆盖层，适合弹窗类场景。方法如下图所示。Figma交互模块有很多功能，感兴趣的可以自行探索，而对于大部分设计师来讲，掌握最基础的Figma交互原型功能就已经能够让你的演示事半功倍了。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/84666e4083294a85aeaaf81802a2f087.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "输出"
    }), "\n", _jsx(_components.p, {
      children: "直接分享链接给对应的利益相关者即可。PM可以在视觉稿上直接评论，快捷沟通解决问题。开发可以切换到开发者模式查看切图标注。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/cf1337733d1745f69da99291f289de76.png",
        alt: ""
      })
    }), "\n", _jsx(_components.h3, {
      children: "插件"
    }), "\n", _jsx(_components.p, {
      children: "Figma与Sketch一样有众多插件可以帮助设计师提升设计效率，甚至某些基础功能如等比缩放也需要插件帮助实现。"
    }), "\n", _jsx(_components.p, {
      children: "插件可以通过系统菜单中的Plugin来安装和调用。具体位置为Plugin-manage plugin。想要搜索新的插件只需要点开一个已安装插件，在插件详情页的顶部使用搜索工具来寻找目标插件。"
    }), "\n", _jsx(_components.p, {
      children: "下面列出了几个我最常用的插件。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Arrow Auto"
      })
    }), "\n", _jsx(_components.p, {
      children: "Arrow Auto是一个原型连线工具，能够快速在选中的元素、画板间连线，且可以自由选择线段两端的样式。由于Figma官方的交互连接线需要在Protype模式下才可以查看，存在无法覆盖的场景。"
    }), "\n", _jsx(_components.p, {
      children: "因此当设计师需要快速展示交互逻辑时，Arrow Auto是一个不错的选择，。除此之外，需要输出中低保真度原型的交互设计师和PM也可以使用它来快速构建MVP原型。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/9dbf36bac8964b3a8afcdcdfc82f2385.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Time machine"
      })
    }), "\n", _jsx(_components.p, {
      children: "TIme machine是一款时间机器类插件，可以帮助设计师快速储存历史版本设计稿，并通过时间线命名。虽然Figma自带30天可追述历史版本的功能，但保存一份备份版文件还是有其必要性的。"
    }), "\n", _jsx(_components.p, {
      children: "设计师只需要选择对应的画板，执行plugin-TIme machine，就会自动生成一个以时间命名的Layer，用来存放历史备份。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/341631ed3c9f4776b6157ba92f2d275b.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Clean Document"
      })
    }), "\n", _jsx(_components.p, {
      children: "Clean Document是一款图层清理插件，可以帮助设计师快速清理隐藏的图层，解除单个图层的分组，批量规范图层命名等。设计师可以在插件页面中选择自己需要执行的清理工作，然后执行清理操作，期间需要花费一定时间，为了避免卡顿可以少量选中画板分批清理。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/be091eab2fe84765af23383857cbf3b7.png",
        alt: ""
      })
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.strong, {
        children: "Scale"
      })
    }), "\n", _jsx(_components.p, {
      children: "Scale是一款等比缩放插件。由于Figma自带的等比缩放功能无法精确按照数值进行操作，因此当设计师需要对设计元素进行等比缩放时，需要适用该插件。"
    }), "\n", _jsx(_components.p, {
      children: _jsx(_components.img, {
        src: "https://s.web.cafe/image/3d410ca0b6304e228c1b5c60d872f6ea.png",
        alt: ""
      })
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = props.components || ({});
  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {
    children: _jsx(_createMdxContent, props)
  })) : _createMdxContent(props);
}
return { default: MDXContent };3:[["$","html",null,{"lang":"zh-CN","className":"scroll-smooth","suppressHydrationWarning":true,"children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.loli.net"}],["$","link",null,{"rel":"preconnect","href":"https://gstatic.loli.net","crossOrigin":""}],["$","link",null,{"href":"https://fonts.loli.net/css2?family=Inter:wght@400;500;700;900&family=Noto+Sans+SC:wght@400;500;700;900&display=swap","rel":"stylesheet"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#000000"}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: light)","content":"#fff"}],["$","meta",null,{"name":"theme-color","media":"(prefers-color-scheme: dark)","content":"#000"}],["$","link",null,{"rel":"alternate","type":"application/rss+xml","href":"/feed.xml"}]]}],["$","body",null,{"className":"bg-white/90 text-black antialiased dark:bg-[#1B1B1B] dark:text-white transition-colors duration-200","children":["$","$L5",null,{"children":["$","section",null,{"className":"mx-auto max-w-6xl px-3 md:px-4 xl:px-0","children":["$","div",null,{"className":"flex h-screen flex-col justify-between font-sans","children":[["$","$L6",null,{"kbarConfig":{"searchDocumentsPath":"search.json"},"children":[["$","$L7",null,{}],["$","$L8",null,{}],["$","main",null,{"className":"mb-auto","children":["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$La",null,{}],"templateStyles":"$undefined","notFound":["$","div",null,{"className":"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6","children":[["$","div",null,{"className":"space-x-2 pb-8 pt-6 md:space-y-5","children":["$","h1",null,{"className":"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14","children":"404"}]}],["$","div",null,{"className":"max-w-md","children":[["$","p",null,{"className":"mb-4 text-xl font-bold leading-normal md:text-2xl","children":"Sorry we couldn't find this page."}],["$","p",null,{"className":"mb-8","children":"But dont worry, you can find plenty of other things on our homepage."}],["$","$Lb",null,{"href":"/","className":"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500","children":"Back to homepage"}]]}]]}],"notFoundStyles":[],"childProp":{"current":["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$La",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L9",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children",["slug","02-ai-tools/2.3-figma-ui-design","oc"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$La",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":[["$","$Lc",null,{"docsForSidebar":[{"slug":"01-development-preparation/1.0-development-preparation-overview","title":"1.0 开发前期准备","order":1,"url":"/docs/01-development-preparation/1.0-development-preparation-overview"},{"slug":"01-development-preparation/1.1-device-purchasing-guide","title":"1.1 开发设备选购指南","order":2,"url":"/docs/01-development-preparation/1.1-device-purchasing-guide"},{"slug":"01-development-preparation/1.2-essential-accounts","title":"1.2 必备开发账号注册","order":3,"url":"/docs/01-development-preparation/1.2-essential-accounts"},{"slug":"01-development-preparation/1.3-essential-software-list","title":"1.3 必备软件清单","order":4,"url":"/docs/01-development-preparation/1.3-essential-software-list"},{"slug":"01-development-preparation/1.4-browser-extensions","title":"1.4 浏览器插件推荐","order":5,"url":"/docs/01-development-preparation/1.4-browser-extensions"},{"slug":"01-development-preparation/1.5-translation-tools-guide","title":"1.5 翻译工具使用指南","order":6,"url":"/docs/01-development-preparation/1.5-translation-tools-guide"},{"slug":"01-development-preparation/1.6-development-environment-setup","title":"1.6 开发环境配置指南","order":7,"url":"/docs/01-development-preparation/1.6-development-environment-setup"},{"slug":"01-development-preparation/1.7-mac-practical-tutorial","title":"1.7 Mac 实用教程","order":8,"url":"/docs/01-development-preparation/1.7-mac-practical-tutorial"},{"slug":"01-development-preparation/1.8-information-search-skills","title":"1.8 信息搜索实操秘技","order":9,"url":"/docs/01-development-preparation/1.8-information-search-skills"},{"slug":"01-development-preparation/1.9-internet-terminology","title":"1.9 互联网常见术语解释","order":10,"url":"/docs/01-development-preparation/1.9-internet-terminology"},{"slug":"02-ai-tools/2.0-software-tools-tutorial","title":"2.0  软件工具教程","order":6,"url":"/docs/02-ai-tools/2.0-software-tools-tutorial"},{"slug":"02-ai-tools/2.1-raycast-efficiency-launcher","title":"2.1 Raycast: 效率启动器","order":7,"url":"/docs/02-ai-tools/2.1-raycast-efficiency-launcher"},{"slug":"02-ai-tools/2.2-github-desktop","title":"2.2 GitHub Desktop","order":8,"url":"/docs/02-ai-tools/2.2-github-desktop"},{"slug":"02-ai-tools/2.3-figma-ui-design","title":"2.3 Figma: UI设计","order":9,"url":"/docs/02-ai-tools/2.3-figma-ui-design"},{"slug":"02-ai-tools/2.4-glarity-ai-assistant","title":"2.4 Glarity: AI助手","order":10,"url":"/docs/02-ai-tools/2.4-glarity-ai-assistant"},{"slug":"02-ai-tools/2.5-sitesucker-website-download","title":"2.5 SiteSucker: 网站下载","order":11,"url":"/docs/02-ai-tools/2.5-sitesucker-website-download"},{"slug":"02-ai-tools/2.6-easyscraper-web-scraping","title":"2.6 Easy Scraper: 网页采集","order":12,"url":"/docs/02-ai-tools/2.6-easyscraper-web-scraping"},{"slug":"02-ai-tools/2.7-lighthouse-performance-testing","title":"2.7 Lighthouse: 性能检测","order":13,"url":"/docs/02-ai-tools/2.7-lighthouse-performance-testing"},{"slug":"03-programming-basics/3.1-cursor-development-cases","title":"3.1 Cursor开发案例","order":17,"url":"/docs/03-programming-basics/3.1-cursor-development-cases"},{"slug":"03-programming-basics/3.2-cursor-installation-configuration","title":"3.2 Cursor安装和配置","order":18,"url":"/docs/03-programming-basics/3.2-cursor-installation-configuration"},{"slug":"03-programming-basics/3.3-cursor-rules","title":"3.3 Cursor Rules","order":19,"url":"/docs/03-programming-basics/3.3-cursor-rules"},{"slug":"03-programming-basics/3.4-cursor-ai-chat","title":"3.4 Cursor AI 对话(Chat)","order":20,"url":"/docs/03-programming-basics/3.4-cursor-ai-chat"},{"slug":"03-programming-basics/3.5-cursor-code-completion","title":"3.5 Cursor代码补全(Tab)","order":21,"url":"/docs/03-programming-basics/3.5-cursor-code-completion"},{"slug":"03-programming-basics/3.6-cursor-ai-agent","title":"3.6 Cursor AI Agent(⌘ I)","order":22,"url":"/docs/03-programming-basics/3.6-cursor-ai-agent"},{"slug":"03-programming-basics/3.7-cursor-command-palette","title":"3.7 Cursor 命令面板(⌘ K)","order":23,"url":"/docs/03-programming-basics/3.7-cursor-command-palette"},{"slug":"03-programming-basics/3.8-cursor-development-examples","title":"3.8 Cursor 开发案例","order":24,"url":"/docs/03-programming-basics/3.8-cursor-development-examples"},{"slug":"04-advanced-techniques/4.0-advanced-prompt-engineering","title":"4.0 全栈开发指南-概览","order":25,"url":"/docs/04-advanced-techniques/4.0-advanced-prompt-engineering"},{"slug":"04-advanced-techniques/4.1-large-project-architecture","title":"4.1 网站类型","order":26,"url":"/docs/04-advanced-techniques/4.1-large-project-architecture"},{"slug":"04-advanced-techniques/4.10-api-design-integration","title":"4.10 API 开发实战教程","order":36,"url":"/docs/04-advanced-techniques/4.10-api-design-integration"},{"slug":"04-advanced-techniques/4.11-ai-driven-automated-testing","title":"4.11 免费 API 资源","order":37,"url":"/docs/04-advanced-techniques/4.11-ai-driven-automated-testing"},{"slug":"04-advanced-techniques/4.12-cloud-native-development","title":"4.12 域名购买与管理","order":38,"url":"/docs/04-advanced-techniques/4.12-cloud-native-development"},{"slug":"04-advanced-techniques/4.13-machine-learning-integration","title":"4.13 Cloudflare 教程","order":39,"url":"/docs/04-advanced-techniques/4.13-machine-learning-integration"},{"slug":"04-advanced-techniques/4.14-real-time-data-processing","title":"4.14 gh-pages静态网站托管","order":40,"url":"/docs/04-advanced-techniques/4.14-real-time-data-processing"},{"slug":"04-advanced-techniques/4.15-scalable-system-design","title":"4.15 Vercel 部署指南","order":41,"url":"/docs/04-advanced-techniques/4.15-scalable-system-design"},{"slug":"04-advanced-techniques/4.16-internationalization-localization","title":"4.16 企业邮箱教程","order":42,"url":"/docs/04-advanced-techniques/4.16-internationalization-localization"},{"slug":"04-advanced-techniques/4.17-technical-debt-management","title":"4.17 网站数据分析工具","order":43,"url":"/docs/04-advanced-techniques/4.17-technical-debt-management"},{"slug":"04-advanced-techniques/4.2-advanced-code-generation","title":"4.2 网站基础 HTML/CSS/JS","order":27,"url":"/docs/04-advanced-techniques/4.2-advanced-code-generation"},{"slug":"04-advanced-techniques/4.3-fullstack-development","title":"4.3 Tailwind CSS 样式指南","order":28,"url":"/docs/04-advanced-techniques/4.3-fullstack-development"},{"slug":"04-advanced-techniques/4.4-complex-algorithm-implementation","title":"4.4 Markdown 使用指南","order":29,"url":"/docs/04-advanced-techniques/4.4-complex-algorithm-implementation"},{"slug":"04-advanced-techniques/4.5-team-collaboration-skills","title":"4.5 Git & GitHub 使用指南","order":30,"url":"/docs/04-advanced-techniques/4.5-team-collaboration-skills"},{"slug":"04-advanced-techniques/4.6-performance-optimization","title":"4.6 命令行终端基础","order":32,"url":"/docs/04-advanced-techniques/4.6-performance-optimization"},{"slug":"04-advanced-techniques/4.7-secure-coding-practices","title":"4.7 Next.js 开发指南","order":33,"url":"/docs/04-advanced-techniques/4.7-secure-coding-practices"},{"slug":"04-advanced-techniques/4.8-devops-integration","title":"4.8 shadcn/ui 组件教程","order":34,"url":"/docs/04-advanced-techniques/4.8-devops-integration"},{"slug":"04-advanced-techniques/4.9-cross-platform-development","title":"4.9 数据库使用指南","order":35,"url":"/docs/04-advanced-techniques/4.9-cross-platform-development"},{"slug":"05-project-practice/5.0-ai-programming-practice-overview","title":"5.0 实战项目开发-概览","order":36,"url":"/docs/05-project-practice/5.0-ai-programming-practice-overview"},{"slug":"05-project-practice/5.1-personal-blog-development","title":"5.1 项目初始化配置","order":37,"url":"/docs/05-project-practice/5.1-personal-blog-development"},{"slug":"05-project-practice/5.10-wechat-mini-program-development","title":"5.10 产品营销推广","order":46,"url":"/docs/05-project-practice/5.10-wechat-mini-program-development"},{"slug":"05-project-practice/5.2-ecommerce-website-development","title":"5.2 域名与邮箱配置","order":38,"url":"/docs/05-project-practice/5.2-ecommerce-website-development"},{"slug":"05-project-practice/5.3-social-app-development","title":"5.3 产品需求文档规范","order":39,"url":"/docs/05-project-practice/5.3-social-app-development"},{"slug":"05-project-practice/5.4-office-collaboration-tools","title":"5.4 落地页面开发教程","order":40,"url":"/docs/05-project-practice/5.4-office-collaboration-tools"},{"slug":"05-project-practice/5.5-data-visualization-platform","title":"5.5 Stripe支付集成指南","order":41,"url":"/docs/05-project-practice/5.5-data-visualization-platform"},{"slug":"05-project-practice/5.6-mobile-app-development","title":"5.6 核心功能实现指南","order":42,"url":"/docs/05-project-practice/5.6-mobile-app-development"},{"slug":"05-project-practice/5.7-ai-assistant-development","title":"5.7 SEO优化策略","order":43,"url":"/docs/05-project-practice/5.7-ai-assistant-development"},{"slug":"05-project-practice/5.8-game-development-practice","title":"5.8 项目部署流程","order":44,"url":"/docs/05-project-practice/5.8-game-development-practice"},{"slug":"05-project-practice/5.9-saas-platform-development","title":"5.9 域名配置教程","order":45,"url":"/docs/05-project-practice/5.9-saas-platform-development"}],"currentDoc":{"type":"Doc","_id":"docs/02-ai-tools/2.3-figma-ui-design","title":"2.3 Figma: UI设计","description":"专业的UI/UX设计工具，支持协作和原型设计","order":9,"slug":"02-ai-tools/2.3-figma-ui-design","url":"/docs/02-ai-tools/2.3-figma-ui-design","filePath":"/home/runner/work/blog/blog/data/docs/02-ai-tools/2.3-figma-ui-design.mdx","toc":[],"_raw":{"sourceFilePath":"/home/runner/work/blog/blog/data/docs/02-ai-tools/2.3-figma-ui-design.mdx","sourceFileName":"2.3-figma-ui-design.mdx","sourceFileDir":"/home/runner/work/blog/blog/data/docs/02-ai-tools","contentType":"mdx","flattenedPath":"docs/02-ai-tools/2.3-figma-ui-design"},"body":{"raw":"$d","code":"$e","compiled":"$f"}},"slug":"02-ai-tools/2.3-figma-ui-design"}],null],"segment":"__PAGE__?{\"slug\":[\"02-ai-tools\",\"2.3-figma-ui-design\"]}"},"styles":[]}],"segment":["slug","02-ai-tools/2.3-figma-ui-design","oc"]},"styles":[]}],"segment":"docs"},"styles":[]}]}],["$","$L10",null,{}]]}],["$","footer",null,{"children":["$","div",null,{"className":"mt-16 flex flex-col items-center","children":[["$","div",null,{"className":"mb-3 flex space-x-4","children":[["$","$Lb",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"mailto:zhangyuliang945@gmail.com","children":[["$","span",null,{"className":"sr-only","children":"mail"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","viewBox":"52 42 88 66","className":"fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":[["$","path",null,{"fill":"#4285f4","d":"M58 108h14V74L52 59v43c0 3.32 2.69 6 6 6"}],["$","path",null,{"fill":"#34a853","d":"M120 108h14c3.32 0 6-2.69 6-6V59l-20 15"}],["$","path",null,{"fill":"#fbbc04","d":"M120 48v26l20-15v-8c0-7.42-8.47-11.65-14.4-7.2"}],["$","path",null,{"fill":"#ea4335","d":"M72 74V48l24 18 24-18v26L96 92"}],["$","path",null,{"fill":"#c5221f","d":"M52 51v8l20 15V48l-5.6-4.2c-5.94-4.45-14.4-.22-14.4 7.2"}]]}]]}],["$","$Lb",null,{"className":"text-sm text-gray-500 transition hover:text-gray-600","target":"_blank","rel":"noopener noreferrer","href":"https://github.com/zhangyuliang1994","children":[["$","span",null,{"className":"sr-only","children":"github"}],["$","svg",null,{"viewBox":"0 0 128 128","className":"fill-current text-gray-700 dark:text-gray-200 h-6 w-6","children":["$","g",null,{"fill":"#fffff","children":[["$","path",null,{"fillRule":"evenodd","clipRule":"evenodd","d":"M64 5.103c-33.347 0-60.388 27.035-60.388 60.388 0 26.682 17.303 49.317 41.297 57.303 3.017.56 4.125-1.31 4.125-2.905 0-1.44-.056-6.197-.082-11.243-16.8 3.653-20.345-7.125-20.345-7.125-2.747-6.98-6.705-8.836-6.705-8.836-5.48-3.748.413-3.67.413-3.67 6.063.425 9.257 6.223 9.257 6.223 5.386 9.23 14.127 6.562 17.573 5.02.542-3.903 2.107-6.568 3.834-8.076-13.413-1.525-27.514-6.704-27.514-29.843 0-6.593 2.36-11.98 6.223-16.21-.628-1.52-2.695-7.662.584-15.98 0 0 5.07-1.623 16.61 6.19C53.7 35 58.867 34.327 64 34.304c5.13.023 10.3.694 15.127 2.033 11.526-7.813 16.59-6.19 16.59-6.19 3.287 8.317 1.22 14.46.593 15.98 3.872 4.23 6.215 9.617 6.215 16.21 0 23.194-14.127 28.3-27.574 29.796 2.167 1.874 4.097 5.55 4.097 11.183 0 8.08-.07 14.583-.07 16.572 0 1.607 1.088 3.49 4.148 2.897 23.98-7.994 41.263-30.622 41.263-57.294C124.388 32.14 97.35 5.104 64 5.104z"}],["$","path",null,{"d":"M26.484 91.806c-.133.3-.605.39-1.035.185-.44-.196-.685-.605-.543-.906.13-.31.603-.395 1.04-.188.44.197.69.61.537.91zm2.446 2.729c-.287.267-.85.143-1.232-.28-.396-.42-.47-.983-.177-1.254.298-.266.844-.14 1.24.28.394.426.472.984.17 1.255zM31.312 98.012c-.37.258-.976.017-1.35-.52-.37-.538-.37-1.183.01-1.44.373-.258.97-.025 1.35.507.368.545.368 1.19-.01 1.452zm3.261 3.361c-.33.365-1.036.267-1.552-.23-.527-.487-.674-1.18-.343-1.544.336-.366 1.045-.264 1.564.23.527.486.686 1.18.333 1.543zm4.5 1.951c-.147.473-.825.688-1.51.486-.683-.207-1.13-.76-.99-1.238.14-.477.823-.7 1.512-.485.683.206 1.13.756.988 1.237zm4.943.361c.017.498-.563.91-1.28.92-.723.017-1.308-.387-1.315-.877 0-.503.568-.91 1.29-.924.717-.013 1.306.387 1.306.88zm4.598-.782c.086.485-.413.984-1.126 1.117-.7.13-1.35-.172-1.44-.653-.086-.498.422-.997 1.122-1.126.714-.123 1.354.17 1.444.663zm0 0"}]]}]}]]}],null,null,null,null]}],["$","div",null,{"className":"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400","children":[["$","div",null,{"children":"张晓风"}],["$","div",null,{"children":" • "}],["$","div",null,{"children":"© 2025"}],["$","div",null,{"children":" • "}],["$","$Lb",null,{"href":"/","children":"晓风的博客"}]]}],["$","div",null,{"className":"mb-8 text-sm text-gray-500 dark:text-gray-400","children":["$","a",null,{"href":"https://beian.miit.gov.cn/","className":"hover:text-gray-600 dark:hover:text-gray-300","target":"_blank","rel":"noopener noreferrer","children":"苏ICP备2023046043号"}]}]]}]}]]}]}]}]}]]}],null]
